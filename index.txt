############  
ğŸ”‘ 10 TÃ©cnicas mÃ¡s preguntadas en coding interviews
Two Pointers
OptimizaciÃ³n de recorridos en arrays/strings (ej. detectar palÃ­ndromos, pares con suma objetivo).

Sliding Window
Encontrar subarrays o substrings con cierta propiedad (ej. longitud mÃ­nima, mÃ¡xima suma, anagramas).

Binary Search (y variantes en espacio de bÃºsqueda)
No solo en arrays ordenados, tambiÃ©n en problemas de minimizar/maximizar bajo condiciÃ³n (ej. minimizar capacidad de un barco, sqrt(x)).

Divide and Conquer
Partir problemas grandes en subproblemas mÃ¡s chicos (ej. mergesort, quicksort, bÃºsqueda de elemento pico).

Greedy
SelecciÃ³n local Ã³ptima esperando resultado global Ã³ptimo (ej. interval scheduling, Huffman coding).

Dynamic Programming (Top-Down y Bottom-Up)
Subproblemas recurrentes con sobreposiciÃ³n (ej. knapsack, subsecuencia mÃ¡s larga, caminos mÃ­nimos).

Backtracking / DFS con poda
Generar combinaciones/permutaciones/particiones (ej. N-Queens, combinaciones de sumas).

Graph Traversals (BFS, DFS)
Problemas de rutas, conectividad, ciclos, niveles (ej. shortest path en grid, componentes conectadas).

Hashing + Sets/Maps
Uso para bÃºsquedas O(1) y detecciÃ³n rÃ¡pida (ej. subarray con suma 0, primer carÃ¡cter Ãºnico).

Heap / Priority Queue
Manejo eficiente de â€œk mejoresâ€ o problemas de streaming (ej. top-k elementos, merging k listas).

############  
âš™ï¸ 10 Algoritmos mÃ¡s preguntados

Los clÃ¡sicos que suelen aparecer como desafÃ­os directos o como subrutinas en problemas mÃ¡s grandes:

Binary Search (y variantes: bÃºsqueda de rango, lower_bound, upper_bound).

Merge Sort (divide y vencerÃ¡s, base de muchos problemas de inversions counting).

Quick Sort / Quick Select (para encontrar el k-Ã©simo elemento mÃ¡s grande/pequeÃ±o).

Breadth-First Search (BFS) (shortest path en grafos no ponderados).

Depth-First Search (DFS) (detecciÃ³n de ciclos, conectividad).

Dijkstraâ€™s Algorithm (shortest path en grafos ponderados positivos).

Union-Find / Disjoint Set Union (DSU) (detecciÃ³n de ciclos, problemas de conectividad en grafos).

Kadaneâ€™s Algorithm (mÃ¡xima suma subarray en O(n)).

KMP (Knuthâ€“Morrisâ€“Pratt) (string matching eficiente).

Trie-based Algorithms (autocomplete, prefix search, word search).

############  Ejemplos tÃ­picos que aparecen en coding rounds:

â€œDado un array, encuentra el subarray de suma mÃ¡ximaâ€ â†’ Kadane + Sliding Window

â€œDiseÃ±a un sistema de autocompleteâ€ â†’ Trie + Priority Queue

â€œEncuentra la ruta mÃ¡s corta en un grid con obstÃ¡culosâ€ â†’ BFS / Dijkstra

â€œDetecta ciclos en un grafo dirigidoâ€ â†’ DFS + Union-Find

â€œK-th largest element en un array giganteâ€ â†’ Quickselect / Heap
